// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machine.proto

#ifndef PROTOBUF_machine_2eproto__INCLUDED
#define PROTOBUF_machine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_machine_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMachine_MemoryImpl();
void InitDefaultsMachine_Memory();
void InitDefaultsMachine_CPUImpl();
void InitDefaultsMachine_CPU();
void InitDefaultsMachine_ProcessImpl();
void InitDefaultsMachine_Process();
void InitDefaultsMachine_SystemInfoImpl();
void InitDefaultsMachine_SystemInfo();
void InitDefaultsMachineImpl();
void InitDefaultsMachine();
void InitDefaultsMachineInfoImpl();
void InitDefaultsMachineInfo();
inline void InitDefaults() {
  InitDefaultsMachine_Memory();
  InitDefaultsMachine_CPU();
  InitDefaultsMachine_Process();
  InitDefaultsMachine_SystemInfo();
  InitDefaultsMachine();
  InitDefaultsMachineInfo();
}
}  // namespace protobuf_machine_2eproto
namespace machine {
class Machine;
class MachineDefaultTypeInternal;
extern MachineDefaultTypeInternal _Machine_default_instance_;
class MachineInfo;
class MachineInfoDefaultTypeInternal;
extern MachineInfoDefaultTypeInternal _MachineInfo_default_instance_;
class Machine_CPU;
class Machine_CPUDefaultTypeInternal;
extern Machine_CPUDefaultTypeInternal _Machine_CPU_default_instance_;
class Machine_Memory;
class Machine_MemoryDefaultTypeInternal;
extern Machine_MemoryDefaultTypeInternal _Machine_Memory_default_instance_;
class Machine_Process;
class Machine_ProcessDefaultTypeInternal;
extern Machine_ProcessDefaultTypeInternal _Machine_Process_default_instance_;
class Machine_SystemInfo;
class Machine_SystemInfoDefaultTypeInternal;
extern Machine_SystemInfoDefaultTypeInternal _Machine_SystemInfo_default_instance_;
}  // namespace machine
namespace machine {

// ===================================================================

class Machine_Memory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machine.Machine.Memory) */ {
 public:
  Machine_Memory();
  virtual ~Machine_Memory();

  Machine_Memory(const Machine_Memory& from);

  inline Machine_Memory& operator=(const Machine_Memory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_Memory(Machine_Memory&& from) noexcept
    : Machine_Memory() {
    *this = ::std::move(from);
  }

  inline Machine_Memory& operator=(Machine_Memory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_Memory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_Memory* internal_default_instance() {
    return reinterpret_cast<const Machine_Memory*>(
               &_Machine_Memory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Machine_Memory* other);
  friend void swap(Machine_Memory& a, Machine_Memory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_Memory* New() const PROTOBUF_FINAL { return New(NULL); }

  Machine_Memory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Machine_Memory& from);
  void MergeFrom(const Machine_Memory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Machine_Memory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 mem_total = 1;
  void clear_mem_total();
  static const int kMemTotalFieldNumber = 1;
  ::google::protobuf::int32 mem_total() const;
  void set_mem_total(::google::protobuf::int32 value);

  // int32 mem_available = 2;
  void clear_mem_available();
  static const int kMemAvailableFieldNumber = 2;
  ::google::protobuf::int32 mem_available() const;
  void set_mem_available(::google::protobuf::int32 value);

  // int32 mem_free = 3;
  void clear_mem_free();
  static const int kMemFreeFieldNumber = 3;
  ::google::protobuf::int32 mem_free() const;
  void set_mem_free(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machine.Machine.Memory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 mem_total_;
  ::google::protobuf::int32 mem_available_;
  ::google::protobuf::int32 mem_free_;
  mutable int _cached_size_;
  friend struct ::protobuf_machine_2eproto::TableStruct;
  friend void ::protobuf_machine_2eproto::InitDefaultsMachine_MemoryImpl();
};
// -------------------------------------------------------------------

class Machine_CPU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machine.Machine.CPU) */ {
 public:
  Machine_CPU();
  virtual ~Machine_CPU();

  Machine_CPU(const Machine_CPU& from);

  inline Machine_CPU& operator=(const Machine_CPU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_CPU(Machine_CPU&& from) noexcept
    : Machine_CPU() {
    *this = ::std::move(from);
  }

  inline Machine_CPU& operator=(Machine_CPU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_CPU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_CPU* internal_default_instance() {
    return reinterpret_cast<const Machine_CPU*>(
               &_Machine_CPU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Machine_CPU* other);
  friend void swap(Machine_CPU& a, Machine_CPU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_CPU* New() const PROTOBUF_FINAL { return New(NULL); }

  Machine_CPU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Machine_CPU& from);
  void MergeFrom(const Machine_CPU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Machine_CPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float idle_time = 1;
  void clear_idle_time();
  static const int kIdleTimeFieldNumber = 1;
  float idle_time() const;
  void set_idle_time(float value);

  // float use_time = 2;
  void clear_use_time();
  static const int kUseTimeFieldNumber = 2;
  float use_time() const;
  void set_use_time(float value);

  // @@protoc_insertion_point(class_scope:machine.Machine.CPU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float idle_time_;
  float use_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_machine_2eproto::TableStruct;
  friend void ::protobuf_machine_2eproto::InitDefaultsMachine_CPUImpl();
};
// -------------------------------------------------------------------

class Machine_Process : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machine.Machine.Process) */ {
 public:
  Machine_Process();
  virtual ~Machine_Process();

  Machine_Process(const Machine_Process& from);

  inline Machine_Process& operator=(const Machine_Process& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_Process(Machine_Process&& from) noexcept
    : Machine_Process() {
    *this = ::std::move(from);
  }

  inline Machine_Process& operator=(Machine_Process&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_Process& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_Process* internal_default_instance() {
    return reinterpret_cast<const Machine_Process*>(
               &_Machine_Process_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Machine_Process* other);
  friend void swap(Machine_Process& a, Machine_Process& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_Process* New() const PROTOBUF_FINAL { return New(NULL); }

  Machine_Process* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Machine_Process& from);
  void MergeFrom(const Machine_Process& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Machine_Process* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 total = 1;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int32 total() const;
  void set_total(::google::protobuf::int32 value);

  // int32 running = 2;
  void clear_running();
  static const int kRunningFieldNumber = 2;
  ::google::protobuf::int32 running() const;
  void set_running(::google::protobuf::int32 value);

  // int32 blocked = 3;
  void clear_blocked();
  static const int kBlockedFieldNumber = 3;
  ::google::protobuf::int32 blocked() const;
  void set_blocked(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machine.Machine.Process)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 running_;
  ::google::protobuf::int32 blocked_;
  mutable int _cached_size_;
  friend struct ::protobuf_machine_2eproto::TableStruct;
  friend void ::protobuf_machine_2eproto::InitDefaultsMachine_ProcessImpl();
};
// -------------------------------------------------------------------

class Machine_SystemInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machine.Machine.SystemInfo) */ {
 public:
  Machine_SystemInfo();
  virtual ~Machine_SystemInfo();

  Machine_SystemInfo(const Machine_SystemInfo& from);

  inline Machine_SystemInfo& operator=(const Machine_SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_SystemInfo(Machine_SystemInfo&& from) noexcept
    : Machine_SystemInfo() {
    *this = ::std::move(from);
  }

  inline Machine_SystemInfo& operator=(Machine_SystemInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_SystemInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_SystemInfo* internal_default_instance() {
    return reinterpret_cast<const Machine_SystemInfo*>(
               &_Machine_SystemInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Machine_SystemInfo* other);
  friend void swap(Machine_SystemInfo& a, Machine_SystemInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_SystemInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Machine_SystemInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Machine_SystemInfo& from);
  void MergeFrom(const Machine_SystemInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Machine_SystemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string system_ip = 1;
  void clear_system_ip();
  static const int kSystemIpFieldNumber = 1;
  const ::std::string& system_ip() const;
  void set_system_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_system_ip(::std::string&& value);
  #endif
  void set_system_ip(const char* value);
  void set_system_ip(const char* value, size_t size);
  ::std::string* mutable_system_ip();
  ::std::string* release_system_ip();
  void set_allocated_system_ip(::std::string* system_ip);

  // string system_name = 2;
  void clear_system_name();
  static const int kSystemNameFieldNumber = 2;
  const ::std::string& system_name() const;
  void set_system_name(const ::std::string& value);
  #if LANG_CXX11
  void set_system_name(::std::string&& value);
  #endif
  void set_system_name(const char* value);
  void set_system_name(const char* value, size_t size);
  ::std::string* mutable_system_name();
  ::std::string* release_system_name();
  void set_allocated_system_name(::std::string* system_name);

  // @@protoc_insertion_point(class_scope:machine.Machine.SystemInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr system_ip_;
  ::google::protobuf::internal::ArenaStringPtr system_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_machine_2eproto::TableStruct;
  friend void ::protobuf_machine_2eproto::InitDefaultsMachine_SystemInfoImpl();
};
// -------------------------------------------------------------------

class Machine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machine.Machine) */ {
 public:
  Machine();
  virtual ~Machine();

  Machine(const Machine& from);

  inline Machine& operator=(const Machine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine(Machine&& from) noexcept
    : Machine() {
    *this = ::std::move(from);
  }

  inline Machine& operator=(Machine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine* internal_default_instance() {
    return reinterpret_cast<const Machine*>(
               &_Machine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Machine* other);
  friend void swap(Machine& a, Machine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine* New() const PROTOBUF_FINAL { return New(NULL); }

  Machine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Machine& from);
  void MergeFrom(const Machine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Machine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Machine_Memory Memory;
  typedef Machine_CPU CPU;
  typedef Machine_Process Process;
  typedef Machine_SystemInfo SystemInfo;

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp last_updated = 5;
  bool has_last_updated() const;
  void clear_last_updated();
  static const int kLastUpdatedFieldNumber = 5;
  const ::google::protobuf::Timestamp& last_updated() const;
  ::google::protobuf::Timestamp* release_last_updated();
  ::google::protobuf::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::google::protobuf::Timestamp* last_updated);

  // .machine.Machine.Memory memory = 6;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 6;
  const ::machine::Machine_Memory& memory() const;
  ::machine::Machine_Memory* release_memory();
  ::machine::Machine_Memory* mutable_memory();
  void set_allocated_memory(::machine::Machine_Memory* memory);

  // .machine.Machine.CPU cpu = 7;
  bool has_cpu() const;
  void clear_cpu();
  static const int kCpuFieldNumber = 7;
  const ::machine::Machine_CPU& cpu() const;
  ::machine::Machine_CPU* release_cpu();
  ::machine::Machine_CPU* mutable_cpu();
  void set_allocated_cpu(::machine::Machine_CPU* cpu);

  // .machine.Machine.Process process = 8;
  bool has_process() const;
  void clear_process();
  static const int kProcessFieldNumber = 8;
  const ::machine::Machine_Process& process() const;
  ::machine::Machine_Process* release_process();
  ::machine::Machine_Process* mutable_process();
  void set_allocated_process(::machine::Machine_Process* process);

  // .machine.Machine.SystemInfo systeminfo = 9;
  bool has_systeminfo() const;
  void clear_systeminfo();
  static const int kSysteminfoFieldNumber = 9;
  const ::machine::Machine_SystemInfo& systeminfo() const;
  ::machine::Machine_SystemInfo* release_systeminfo();
  ::machine::Machine_SystemInfo* mutable_systeminfo();
  void set_allocated_systeminfo(::machine::Machine_SystemInfo* systeminfo);

  // @@protoc_insertion_point(class_scope:machine.Machine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* last_updated_;
  ::machine::Machine_Memory* memory_;
  ::machine::Machine_CPU* cpu_;
  ::machine::Machine_Process* process_;
  ::machine::Machine_SystemInfo* systeminfo_;
  mutable int _cached_size_;
  friend struct ::protobuf_machine_2eproto::TableStruct;
  friend void ::protobuf_machine_2eproto::InitDefaultsMachineImpl();
};
// -------------------------------------------------------------------

class MachineInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machine.MachineInfo) */ {
 public:
  MachineInfo();
  virtual ~MachineInfo();

  MachineInfo(const MachineInfo& from);

  inline MachineInfo& operator=(const MachineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MachineInfo(MachineInfo&& from) noexcept
    : MachineInfo() {
    *this = ::std::move(from);
  }

  inline MachineInfo& operator=(MachineInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MachineInfo* internal_default_instance() {
    return reinterpret_cast<const MachineInfo*>(
               &_MachineInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MachineInfo* other);
  friend void swap(MachineInfo& a, MachineInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MachineInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MachineInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MachineInfo& from);
  void MergeFrom(const MachineInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MachineInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .machine.Machine machine = 1;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 1;
  const ::machine::Machine& machine() const;
  ::machine::Machine* release_machine();
  ::machine::Machine* mutable_machine();
  void set_allocated_machine(::machine::Machine* machine);

  // @@protoc_insertion_point(class_scope:machine.MachineInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::machine::Machine* machine_;
  mutable int _cached_size_;
  friend struct ::protobuf_machine_2eproto::TableStruct;
  friend void ::protobuf_machine_2eproto::InitDefaultsMachineInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Machine_Memory

// int32 mem_total = 1;
inline void Machine_Memory::clear_mem_total() {
  mem_total_ = 0;
}
inline ::google::protobuf::int32 Machine_Memory::mem_total() const {
  // @@protoc_insertion_point(field_get:machine.Machine.Memory.mem_total)
  return mem_total_;
}
inline void Machine_Memory::set_mem_total(::google::protobuf::int32 value) {
  
  mem_total_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.Memory.mem_total)
}

// int32 mem_available = 2;
inline void Machine_Memory::clear_mem_available() {
  mem_available_ = 0;
}
inline ::google::protobuf::int32 Machine_Memory::mem_available() const {
  // @@protoc_insertion_point(field_get:machine.Machine.Memory.mem_available)
  return mem_available_;
}
inline void Machine_Memory::set_mem_available(::google::protobuf::int32 value) {
  
  mem_available_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.Memory.mem_available)
}

// int32 mem_free = 3;
inline void Machine_Memory::clear_mem_free() {
  mem_free_ = 0;
}
inline ::google::protobuf::int32 Machine_Memory::mem_free() const {
  // @@protoc_insertion_point(field_get:machine.Machine.Memory.mem_free)
  return mem_free_;
}
inline void Machine_Memory::set_mem_free(::google::protobuf::int32 value) {
  
  mem_free_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.Memory.mem_free)
}

// -------------------------------------------------------------------

// Machine_CPU

// float idle_time = 1;
inline void Machine_CPU::clear_idle_time() {
  idle_time_ = 0;
}
inline float Machine_CPU::idle_time() const {
  // @@protoc_insertion_point(field_get:machine.Machine.CPU.idle_time)
  return idle_time_;
}
inline void Machine_CPU::set_idle_time(float value) {
  
  idle_time_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.CPU.idle_time)
}

// float use_time = 2;
inline void Machine_CPU::clear_use_time() {
  use_time_ = 0;
}
inline float Machine_CPU::use_time() const {
  // @@protoc_insertion_point(field_get:machine.Machine.CPU.use_time)
  return use_time_;
}
inline void Machine_CPU::set_use_time(float value) {
  
  use_time_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.CPU.use_time)
}

// -------------------------------------------------------------------

// Machine_Process

// int32 total = 1;
inline void Machine_Process::clear_total() {
  total_ = 0;
}
inline ::google::protobuf::int32 Machine_Process::total() const {
  // @@protoc_insertion_point(field_get:machine.Machine.Process.total)
  return total_;
}
inline void Machine_Process::set_total(::google::protobuf::int32 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.Process.total)
}

// int32 running = 2;
inline void Machine_Process::clear_running() {
  running_ = 0;
}
inline ::google::protobuf::int32 Machine_Process::running() const {
  // @@protoc_insertion_point(field_get:machine.Machine.Process.running)
  return running_;
}
inline void Machine_Process::set_running(::google::protobuf::int32 value) {
  
  running_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.Process.running)
}

// int32 blocked = 3;
inline void Machine_Process::clear_blocked() {
  blocked_ = 0;
}
inline ::google::protobuf::int32 Machine_Process::blocked() const {
  // @@protoc_insertion_point(field_get:machine.Machine.Process.blocked)
  return blocked_;
}
inline void Machine_Process::set_blocked(::google::protobuf::int32 value) {
  
  blocked_ = value;
  // @@protoc_insertion_point(field_set:machine.Machine.Process.blocked)
}

// -------------------------------------------------------------------

// Machine_SystemInfo

// string system_ip = 1;
inline void Machine_SystemInfo::clear_system_ip() {
  system_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_SystemInfo::system_ip() const {
  // @@protoc_insertion_point(field_get:machine.Machine.SystemInfo.system_ip)
  return system_ip_.GetNoArena();
}
inline void Machine_SystemInfo::set_system_ip(const ::std::string& value) {
  
  system_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machine.Machine.SystemInfo.system_ip)
}
#if LANG_CXX11
inline void Machine_SystemInfo::set_system_ip(::std::string&& value) {
  
  system_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machine.Machine.SystemInfo.system_ip)
}
#endif
inline void Machine_SystemInfo::set_system_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machine.Machine.SystemInfo.system_ip)
}
inline void Machine_SystemInfo::set_system_ip(const char* value, size_t size) {
  
  system_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machine.Machine.SystemInfo.system_ip)
}
inline ::std::string* Machine_SystemInfo::mutable_system_ip() {
  
  // @@protoc_insertion_point(field_mutable:machine.Machine.SystemInfo.system_ip)
  return system_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_SystemInfo::release_system_ip() {
  // @@protoc_insertion_point(field_release:machine.Machine.SystemInfo.system_ip)
  
  return system_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_SystemInfo::set_allocated_system_ip(::std::string* system_ip) {
  if (system_ip != NULL) {
    
  } else {
    
  }
  system_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_ip);
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.SystemInfo.system_ip)
}

// string system_name = 2;
inline void Machine_SystemInfo::clear_system_name() {
  system_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_SystemInfo::system_name() const {
  // @@protoc_insertion_point(field_get:machine.Machine.SystemInfo.system_name)
  return system_name_.GetNoArena();
}
inline void Machine_SystemInfo::set_system_name(const ::std::string& value) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machine.Machine.SystemInfo.system_name)
}
#if LANG_CXX11
inline void Machine_SystemInfo::set_system_name(::std::string&& value) {
  
  system_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machine.Machine.SystemInfo.system_name)
}
#endif
inline void Machine_SystemInfo::set_system_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machine.Machine.SystemInfo.system_name)
}
inline void Machine_SystemInfo::set_system_name(const char* value, size_t size) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machine.Machine.SystemInfo.system_name)
}
inline ::std::string* Machine_SystemInfo::mutable_system_name() {
  
  // @@protoc_insertion_point(field_mutable:machine.Machine.SystemInfo.system_name)
  return system_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_SystemInfo::release_system_name() {
  // @@protoc_insertion_point(field_release:machine.Machine.SystemInfo.system_name)
  
  return system_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_SystemInfo::set_allocated_system_name(::std::string* system_name) {
  if (system_name != NULL) {
    
  } else {
    
  }
  system_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_name);
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.SystemInfo.system_name)
}

// -------------------------------------------------------------------

// Machine

// .machine.Machine.Memory memory = 6;
inline bool Machine::has_memory() const {
  return this != internal_default_instance() && memory_ != NULL;
}
inline void Machine::clear_memory() {
  if (GetArenaNoVirtual() == NULL && memory_ != NULL) {
    delete memory_;
  }
  memory_ = NULL;
}
inline const ::machine::Machine_Memory& Machine::memory() const {
  const ::machine::Machine_Memory* p = memory_;
  // @@protoc_insertion_point(field_get:machine.Machine.memory)
  return p != NULL ? *p : *reinterpret_cast<const ::machine::Machine_Memory*>(
      &::machine::_Machine_Memory_default_instance_);
}
inline ::machine::Machine_Memory* Machine::release_memory() {
  // @@protoc_insertion_point(field_release:machine.Machine.memory)
  
  ::machine::Machine_Memory* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline ::machine::Machine_Memory* Machine::mutable_memory() {
  
  if (memory_ == NULL) {
    memory_ = new ::machine::Machine_Memory;
  }
  // @@protoc_insertion_point(field_mutable:machine.Machine.memory)
  return memory_;
}
inline void Machine::set_allocated_memory(::machine::Machine_Memory* memory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete memory_;
  }
  if (memory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      memory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, memory, submessage_arena);
    }
    
  } else {
    
  }
  memory_ = memory;
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.memory)
}

// .machine.Machine.CPU cpu = 7;
inline bool Machine::has_cpu() const {
  return this != internal_default_instance() && cpu_ != NULL;
}
inline void Machine::clear_cpu() {
  if (GetArenaNoVirtual() == NULL && cpu_ != NULL) {
    delete cpu_;
  }
  cpu_ = NULL;
}
inline const ::machine::Machine_CPU& Machine::cpu() const {
  const ::machine::Machine_CPU* p = cpu_;
  // @@protoc_insertion_point(field_get:machine.Machine.cpu)
  return p != NULL ? *p : *reinterpret_cast<const ::machine::Machine_CPU*>(
      &::machine::_Machine_CPU_default_instance_);
}
inline ::machine::Machine_CPU* Machine::release_cpu() {
  // @@protoc_insertion_point(field_release:machine.Machine.cpu)
  
  ::machine::Machine_CPU* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline ::machine::Machine_CPU* Machine::mutable_cpu() {
  
  if (cpu_ == NULL) {
    cpu_ = new ::machine::Machine_CPU;
  }
  // @@protoc_insertion_point(field_mutable:machine.Machine.cpu)
  return cpu_;
}
inline void Machine::set_allocated_cpu(::machine::Machine_CPU* cpu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cpu_;
  }
  if (cpu) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cpu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    
  } else {
    
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.cpu)
}

// .machine.Machine.Process process = 8;
inline bool Machine::has_process() const {
  return this != internal_default_instance() && process_ != NULL;
}
inline void Machine::clear_process() {
  if (GetArenaNoVirtual() == NULL && process_ != NULL) {
    delete process_;
  }
  process_ = NULL;
}
inline const ::machine::Machine_Process& Machine::process() const {
  const ::machine::Machine_Process* p = process_;
  // @@protoc_insertion_point(field_get:machine.Machine.process)
  return p != NULL ? *p : *reinterpret_cast<const ::machine::Machine_Process*>(
      &::machine::_Machine_Process_default_instance_);
}
inline ::machine::Machine_Process* Machine::release_process() {
  // @@protoc_insertion_point(field_release:machine.Machine.process)
  
  ::machine::Machine_Process* temp = process_;
  process_ = NULL;
  return temp;
}
inline ::machine::Machine_Process* Machine::mutable_process() {
  
  if (process_ == NULL) {
    process_ = new ::machine::Machine_Process;
  }
  // @@protoc_insertion_point(field_mutable:machine.Machine.process)
  return process_;
}
inline void Machine::set_allocated_process(::machine::Machine_Process* process) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete process_;
  }
  if (process) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      process = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  process_ = process;
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.process)
}

// .machine.Machine.SystemInfo systeminfo = 9;
inline bool Machine::has_systeminfo() const {
  return this != internal_default_instance() && systeminfo_ != NULL;
}
inline void Machine::clear_systeminfo() {
  if (GetArenaNoVirtual() == NULL && systeminfo_ != NULL) {
    delete systeminfo_;
  }
  systeminfo_ = NULL;
}
inline const ::machine::Machine_SystemInfo& Machine::systeminfo() const {
  const ::machine::Machine_SystemInfo* p = systeminfo_;
  // @@protoc_insertion_point(field_get:machine.Machine.systeminfo)
  return p != NULL ? *p : *reinterpret_cast<const ::machine::Machine_SystemInfo*>(
      &::machine::_Machine_SystemInfo_default_instance_);
}
inline ::machine::Machine_SystemInfo* Machine::release_systeminfo() {
  // @@protoc_insertion_point(field_release:machine.Machine.systeminfo)
  
  ::machine::Machine_SystemInfo* temp = systeminfo_;
  systeminfo_ = NULL;
  return temp;
}
inline ::machine::Machine_SystemInfo* Machine::mutable_systeminfo() {
  
  if (systeminfo_ == NULL) {
    systeminfo_ = new ::machine::Machine_SystemInfo;
  }
  // @@protoc_insertion_point(field_mutable:machine.Machine.systeminfo)
  return systeminfo_;
}
inline void Machine::set_allocated_systeminfo(::machine::Machine_SystemInfo* systeminfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete systeminfo_;
  }
  if (systeminfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      systeminfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, systeminfo, submessage_arena);
    }
    
  } else {
    
  }
  systeminfo_ = systeminfo;
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.systeminfo)
}

// .google.protobuf.Timestamp last_updated = 5;
inline bool Machine::has_last_updated() const {
  return this != internal_default_instance() && last_updated_ != NULL;
}
inline const ::google::protobuf::Timestamp& Machine::last_updated() const {
  const ::google::protobuf::Timestamp* p = last_updated_;
  // @@protoc_insertion_point(field_get:machine.Machine.last_updated)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Machine::release_last_updated() {
  // @@protoc_insertion_point(field_release:machine.Machine.last_updated)
  
  ::google::protobuf::Timestamp* temp = last_updated_;
  last_updated_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Machine::mutable_last_updated() {
  
  if (last_updated_ == NULL) {
    last_updated_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:machine.Machine.last_updated)
  return last_updated_;
}
inline void Machine::set_allocated_last_updated(::google::protobuf::Timestamp* last_updated) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(last_updated_);
  }
  if (last_updated) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(last_updated)->GetArena();
    if (message_arena != submessage_arena) {
      last_updated = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:machine.Machine.last_updated)
}

// -------------------------------------------------------------------

// MachineInfo

// .machine.Machine machine = 1;
inline bool MachineInfo::has_machine() const {
  return this != internal_default_instance() && machine_ != NULL;
}
inline void MachineInfo::clear_machine() {
  if (GetArenaNoVirtual() == NULL && machine_ != NULL) {
    delete machine_;
  }
  machine_ = NULL;
}
inline const ::machine::Machine& MachineInfo::machine() const {
  const ::machine::Machine* p = machine_;
  // @@protoc_insertion_point(field_get:machine.MachineInfo.machine)
  return p != NULL ? *p : *reinterpret_cast<const ::machine::Machine*>(
      &::machine::_Machine_default_instance_);
}
inline ::machine::Machine* MachineInfo::release_machine() {
  // @@protoc_insertion_point(field_release:machine.MachineInfo.machine)
  
  ::machine::Machine* temp = machine_;
  machine_ = NULL;
  return temp;
}
inline ::machine::Machine* MachineInfo::mutable_machine() {
  
  if (machine_ == NULL) {
    machine_ = new ::machine::Machine;
  }
  // @@protoc_insertion_point(field_mutable:machine.MachineInfo.machine)
  return machine_;
}
inline void MachineInfo::set_allocated_machine(::machine::Machine* machine) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machine_;
  }
  if (machine) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machine = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machine, submessage_arena);
    }
    
  } else {
    
  }
  machine_ = machine;
  // @@protoc_insertion_point(field_set_allocated:machine.MachineInfo.machine)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace machine

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_machine_2eproto__INCLUDED
